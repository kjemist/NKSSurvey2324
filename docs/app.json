[{"name":"app.R","content":"# Plots the results from the 2023-24 Norwegian Chemical Society Survey in an interactive Shiny application\r\n# Illimar Rekand, 2023-24\r\n# email: illimar.rekand@gmail.com\r\n\r\n\r\nlibrary(gsheet)\r\nlibrary(shiny)\r\nlibrary(ggplot2)\r\nlibrary(forcats) #fct_infreq\r\nlibrary(dplyr)\r\nlibrary(tidyverse)\r\nlibrary(ggtext) # fix ggtitle width\r\nlibrary(tm)\r\n\r\n################################################################################################################\r\n################################################ Functions #####################################################\r\n################################################################################################################\r\n\r\nformat_header <<- function(header.txt){\r\n  caption.txt <- header.txt #spaces have been converted to \".\". Below we fix this.\r\n  caption.txt <- gsub(pattern = \"1\\\\.5\", replacement = \"1 to 5\", x = caption.txt) # \".\" means any character. This is why we use \"\\\\.\" instead\r\n  caption.txt <- gsub(pattern = \"\\\\.\\\\.\", replacement = \" \", x = caption.txt) # \".\" means any character. This is why we use \"\\\\.\" instead\r\n  caption.txt <- gsub(pattern = \"\\\\.\", replacement = \" \", x = caption.txt) # \".\" means any character. This is why we use \"\\\\.\" instead\r\n  caption.txt <- paste0(substring(caption.txt, 1, nchar(caption.txt)-1), \"?\") #it's nice to have a question mark at the end of a question, also remove space at end of sentenc\r\n  return(caption.txt)\r\n}\r\n\r\nsubstrRight <- function(x, n){ #from https://stackoverflow.com/a/7963963/11598009\r\n  substr(x, nchar(x)-n+1, nchar(x))\r\n}\r\n\r\n#############################################################################################\r\n################################################ Extracting data ###############################################\r\n################################################################################################################\r\n\r\nurl <- \"https://docs.google.com/spreadsheets/d/15s7zeTEFT-fShou_jVYaHZHT3_9IvF6rgluUUdWy29Q/edit#gid=0\"\r\nsheet <- read.csv(text=gsheet2text(url, format='csv'), stringsAsFactors=FALSE, na.strings=c(\"\",\"NA\")) #emptry rows set to NAhttp://127.0.0.1:38813/graphics/plot_zoom_png?width=1920&height=1009\r\ncolnames(sheet) <- format_header(colnames(sheet))\r\n\r\n################################################################################################################\r\n################################################ Testing plots #################################################\r\n################################################################################################################\r\n\r\ncolumnName <- function(ColumnReference) { #from https://stackoverflow.com/a/14771584/11598009, function to retrieve colname as a string\r\n  return(substring(deparse(substitute(ColumnReference)),which(strsplit(deparse(substitute(ColumnReference)),\"\")[[1]]==\"$\")[1]+1))\r\n}\r\n\r\ncol.name.txt <- columnName(sheet$On.a.scale.from.1.5..how.interesting.do.you.find.the.publication..Kjemi..is.for.you..)\r\ncol.name.fill <- columnName(sheet$You.are..a..)\r\n\r\n#col.name.txt.sub <- gsub(pattern = \"\\\\.\\\\.\", replacement = \" \", x = col.name.txt)\r\n#col.name.txt.sub <- gsub(pattern = \"\\\\.\", replacement = \" \", x = col.name.txt.sub)\r\n\r\nsheet.NA.rm <- subset(sheet, !is.na(sheet[[col.name.txt]]))\r\nnrow(sheet.NA.rm)\r\n\r\n\r\nsheet.individual.means <- sheet.NA.rm %>% group_by(!!sym(col.name.fill)) %>% mutate(avg_score = mean(!!sym(col.name.txt))) %>% group_by(!!sym(col.name.fill))\r\nsheet.NA.rm[[col.name.fill]] <- reorder(sheet.NA.rm[[col.name.fill]], sheet.NA.rm[[col.name.txt]])\r\n\r\nscale.question = T\r\nggplot(sheet.individual.means, aes(x = if (scale.question==TRUE){as.character(sheet.individual.means[[col.name.txt]])}else {fct_rev(fct_infreq(as.character(sheet.individual.means[[col.name.txt]])))},\r\n)) + \r\n  geom_bar(aes(fill= sheet.individual.means[[col.name.fill]])) + \r\n  theme_classic() +\r\n  theme(legend.title = element_blank()\r\n        ) +\r\n  facet_wrap(vars(sheet.individual.means[[col.name.fill]])) +\r\n  geom_vline(aes(xintercept = sheet.individual.means$avg_score), size = 2, alpha = 0.3) +\r\n  geom_text(aes( x = 2.5, y = Inf, label = paste(\"Avg:\", format(round(sheet.individual.means$avg_score, 2), nsmall = 2))), check_overlap = TRUE, hjust=\"inward\", vjust =\"inward\")\r\n\r\n################################################################################################################\r\n################################################ Shiny #########################################################\r\n################################################################################################################\r\n\r\n\r\nui <- bootstrapPage(\r\n  \r\n  # App title ----\r\n  titlePanel(\"Choose input below\"),\r\n  \r\n  # Sidebar layout with input and output definitions ----\r\n  sidebarLayout(\r\n    \r\n    # Sidebar panel for inputs ----\r\n    sidebarPanel(\r\n      \r\n      # Input: Selector for variable to plot against count ----\r\n      # The below variables will be output as character strings\r\n      selectInput(\"variable\", \"Variable:\",\r\n                  choices = names(sheet) #all column names\r\n                    ),\r\n      selectInput(\"fill_value\", \"Fill:\",\r\n                  choices = c(\"None\", names(sheet)) #Adds a none for when filling is not necessary\r\n      ),\r\n      checkboxInput(\"facet.wrap\", \"Facet Wrap?\", value = FALSE),\r\n        numericInput('n_facet', 'Number of top facets', 6, min = 1, max = 7),\r\n        numericInput('font_size', 'Font size', 26),\r\n      numericInput('count_font_size', 'Count font size', 9),\r\n      downloadButton('downloadPlot')\r\n    ),\r\n    \r\n    # Main panel for displaying outputs ----\r\n    mainPanel(\r\n      \r\n      # Output: Formatted text for caption ----\r\n      h3(textOutput(\"caption\")),\r\n      \r\n      # Output: Plot of the requested variable against count ----\r\n      plotOutput(\"nks.plot\")\r\n      \r\n      \r\n    )\r\n  )\r\n)\r\n\r\nserver <- function(input, output) { #shiny passes selectInput as a string. To use these variables for subsetting dataframes, use e.g. df$!!sym(input$variable) or df[[input$variable]]\r\n  \r\n  formulaText <- reactive({\r\n  })\r\n  \r\n  # Return the formula text for printing as a caption ----\r\n  output$caption <- renderText({\r\n    formulaText()\r\n  })\r\n  \r\n  \r\n  # Generate a plot of the requested variable against count ----\r\n#  if(grepl(x = caption.txt, pattern = \"If you answered \")){\r\n    ##prepare Corpus from words\r\n    #text <- sheet[[input$variable]]\r\n    #print(text)\r\n    #docs <- Corpus(VectorSource(text))\r\n    #print(docs)\r\n    #docs <- tm_map(docs, removeWords, stopwords(\"Norwegian\")) #remove common words\r\n    #dtm <- TermDocumentMatrix(docs) #reformat\r\n    #matrix <- as.matrix(dtm) #reformat\r\n    #words <- sort(rowSums(matrix),decreasing=TRUE) \r\n    #df <- data.frame(word = names(words),freq=words)\r\n    #wordcloud_rep <- repeatable(wordcloud)   # Make the wordcloud drawing predictable during a session\r\n    #wordcloud(words = df$word,\r\n              #freq = df$freq,\r\n              #min.freq = 1,\r\n              #random.order=FALSE,\r\n              #rot.per=0.35,\r\n              #colors=brewer.pal(8, \"Dark2\"))\r\n#  }\r\n#  else{\r\n  bar_plot.reactive <- reactive({\r\n    \r\n    caption.txt <- format_header(input$variable)\r\n    \r\n    #scale-question parameters\r\n    scale.question <- grepl(x = input$variable, pattern = \"scale\", ignore.case = TRUE) #is this a question with a ranking from 1-5?\r\n    #unpack lists (cells with comma-separated, multiple values)\r\n    cells.w.multiple.value <- any(grepl(pattern = \",\", x = sheet[[input$variable]])) # check if any cells contain a comma\r\n    unique.answers <- nrow(subset(sheet, !is.na(sheet[[input$variable]])))\r\n    if (cells.w.multiple.value){\r\n      sheet.unpackt <- sheet %>% separate_longer_delim(!!sym(input$variable), delim = \", \")\r\n      sheet <- sheet.unpackt\r\n    }\r\n    \r\n    # remove NA\r\n    sheet.NA.rm <- subset(sheet, !is.na(sheet[[input$variable]]))\r\n    #handling counts for faceted plots\r\n    if(input$facet.wrap&scale.question){ #calculate the mean values pr group for scale questions\r\n      sheet.individual.means <- sheet.NA.rm %>% group_by(!!sym(input$fill_value)) %>% mutate(avg_score = mean(!!sym(input$variable)), na.rm = TRUE) %>% group_by(!!sym(input$variable)) \r\n      sheet.NA.rm <- sheet.individual.means\r\n      sheet.w.count <- sheet.NA.rm %>% group_by(!!sym(input$fill_value)) %>% add_count() #find the counts for each fill value\r\n      count_values <- sort(unique(sheet.w.count$n), decreasing=TRUE) #find unique count values, sorts them high->low\r\n      sheet.top.n.subset <- subset(sheet.w.count, subset = n %in% count_values[1:input$n_facet] ) # creates a subset of the dataset which contains only the top n counts (n is defined in the shiny app as n_facet)\r\n      sheet.NA.rm <- sheet.top.n.subset # pipelines the data\r\n    } else\r\n    if(input$facet.wrap){\r\n      validate(need(input$fill_value != \"None\", \"Please define a fill value\"))\r\n    sheet.w.count <- sheet.NA.rm %>% group_by(!!sym(input$fill_value)) %>% add_count() #find the counts for each fill value\r\n    count_values <- sort(unique(sheet.w.count$n), decreasing=TRUE) #find unique count values, sorts them high->low\r\n\r\n    sheet.top.n.subset <- subset(sheet.w.count, subset = n %in% count_values[1:input$n_facet] ) # creates a subset of the dataset which contains only the top n counts (n is defined in the shiny app as n_facet)\r\n    sheet.NA.rm <- sheet.top.n.subset # pipelines the data\r\n    }\r\n    \r\n    # let's plot\r\n\r\n    ggplot(\r\n      sheet.NA.rm, aes(x = if (scale.question==TRUE){as.character(.data[[input$variable]])} #numerical values from scale-questions are converted to text\r\n                       else {fct_rev(fct_infreq(as.character(.data[[input$variable]])))}\r\n                       ))+ #fct_infreq = order by count, fct_rev = reverse order. Scale questions should not be ordered by count, and needs to converted to character type\r\n    \r\n        {if(input$fill_value == \"None\") #if fill is \"None\", then fill with no color\r\n          geom_bar(fill=\"#005691\")\r\n          }+\r\n        {if(input$fill_value != \"None\")geom_bar( #if fill is defined as other than none, fill with fill parameters\r\n            aes(fill=\r\n                  if(scale.question){as.character(!!sym(input$fill_value))}  #convert scale-numbers (1 to 5) to characters\r\n                  else{!!sym(input$fill_value)}\r\n                  ) \r\n          )\r\n            }+ \r\n      geom_text(stat='count', size = input$count_font_size, aes(label=after_stat(count)), vjust=if(scale.question==FALSE){\"inward\"}else{\"inward\"}, hjust=if(scale.question==\"inward\"){-0.5}else{0}) +\r\n      theme_classic() +\r\n      {if(scale.question==FALSE)coord_flip()} + #scale question should not be coord-flipped.\r\n      {if(scale.question&input$facet.wrap==FALSE)geom_vline(xintercept = mean(sheet.NA.rm[[input$variable]]), size = 3, alpha = 0.4)} +\r\n      {if(scale.question&input$facet.wrap==FALSE)geom_text(aes( x = 2.5, y = Inf, label = paste(\"Avg:\", format(round(mean(sheet.NA.rm[[input$variable]]), 2), nsmall = 2))), check_overlap = TRUE, hjust=+1, vjust =\"inward\", size = (input$font_size/3))} +\r\n      labs(title = caption.txt,\r\n           subtitle = if(scale.question&input$facet.wrap){paste0(\"(n=\",unique.answers,\"/329, Avg:\",format(round(mean(sheet.NA.rm[[input$variable]]), 2), nsmall = 2), \")\")}\r\n           else{paste0(\"(n=\",unique.answers,\"/329)\")}\r\n             ) +\r\n      theme(text = element_text(size = input$font_size),\r\n            plot.title = element_textbox_simple(margin = margin(0,0,20,0)), #textbox enables line breaks, margin increased distance betwen plot/title\r\n            plot.title.position = if(str_length(caption.txt)>50){ \"plot\"}else{\"panel\"}, #if question gets too long, place it further left\r\n            legend.title = element_blank(),\r\n            axis.title.y = element_blank(),\r\n            axis.text.y = element_text(), #face=\"bold\" tested this, not sure if it's nicer\r\n            legend.position=if(input$facet.wrap){\"none\"}else{\"right\"}, \r\n            strip.placement = \"outside\",\r\n            ) +\r\n      {if(scale.question==TRUE)xlab(\"1 = Very little, 5 = Very much\")} + \r\n      ylab(\"Count\") +\r\n      # aggregate(sheet.NA.rm$`On a scale from 1 to 5 how interesting do you find the publication Kjemi is for you?`, list(sheet.NA.rm$`You are?`), mean) #calculate individual mean values\r\n      {if(input$facet.wrap)facet_wrap(.~fct_infreq(sheet.NA.rm[[input$fill_value]]), ncol = 2)} + #create individual plots\r\n      {if(input$facet.wrap&scale.question)geom_vline(aes(xintercept = sheet.NA.rm$avg_score), size = 2, alpha = 0.3)} +\r\n      {if(input$facet.wrap&scale.question)geom_text(aes( x = 1.5, y = Inf, label = paste(\"Group avg:\", format(round(sheet.NA.rm$avg_score, 2), nsmall = 2))), check_overlap = TRUE, hjust=\"inward\", vjust =\"inward\", size = (input$font_size/3)) }\r\n    \r\n  })\r\n  #}  This bracket is for the else\r\n  \r\n  output$nks.plot <- renderPlot(\r\n    { \r\n      bar_plot.reactive()\r\n    }\r\n  )\r\n  \r\n  output$downloadPlot <- downloadHandler(\r\n    filename <- function()\r\n    { if (input$facet.wrap){\r\n      paste0(\"NKS-plot-\",gsub(substrRight(input$variable, 60), pattern = \" \", replacement = \"_\"),\"-facet-wrap-\",input$fill_value, \".png\")\r\n    }else\r\n    {\r\n      paste0(\"NKS-plot-\",gsub(substrRight(input$variable, 60), pattern = \" \", replacement = \"_\"),\"fill-value-\", input$fill_value, \".png\")\r\n    }\r\n      },\r\n    content <- function(file){\r\n      png(file=file, width = 1500, height = 1000, pointsize = 24) #can we make this work with ggsave? https://stackoverflow.com/questions/14810409/how-to-save-plots-that-are-made-in-a-shiny-app probably not worth the hassle (right now)\r\n      plot(bar_plot.reactive())\r\n      dev.off()\r\n    }\r\n  )\r\n  \r\n  \r\n}\r\n\r\nshinyApp(ui, server)\r\n\r\n","type":"text"},{"name":"2024-03-19-NKS-survey-2023-2024-shiny.R","content":"# Plots the results from the 2023-24 Norwegian Chemical Society Survey in an interactive Shiny application\r\n# Illimar Rekand, 2023-24\r\n# email: illimar.rekand@gmail.com\r\n\r\n\r\nlibrary(gsheet)\r\nlibrary(shiny)\r\nlibrary(ggplot2)\r\nlibrary(forcats) #fct_infreq\r\nlibrary(dplyr)\r\nlibrary(tidyverse)\r\nlibrary(ggtext) # fix ggtitle width\r\nlibrary(tm)\r\n\r\n################################################################################################################\r\n################################################ Functions #####################################################\r\n################################################################################################################\r\n\r\nformat_header <<- function(header.txt){\r\n  caption.txt <- header.txt #spaces have been converted to \".\". Below we fix this.\r\n  caption.txt <- gsub(pattern = \"1\\\\.5\", replacement = \"1 to 5\", x = caption.txt) # \".\" means any character. This is why we use \"\\\\.\" instead\r\n  caption.txt <- gsub(pattern = \"\\\\.\\\\.\", replacement = \" \", x = caption.txt) # \".\" means any character. This is why we use \"\\\\.\" instead\r\n  caption.txt <- gsub(pattern = \"\\\\.\", replacement = \" \", x = caption.txt) # \".\" means any character. This is why we use \"\\\\.\" instead\r\n  caption.txt <- paste0(substring(caption.txt, 1, nchar(caption.txt)-1), \"?\") #it's nice to have a question mark at the end of a question, also remove space at end of sentenc\r\n  return(caption.txt)\r\n}\r\n\r\nsubstrRight <- function(x, n){ #from https://stackoverflow.com/a/7963963/11598009\r\n  substr(x, nchar(x)-n+1, nchar(x))\r\n}\r\n\r\n#############################################################################################\r\n################################################ Extracting data ###############################################\r\n################################################################################################################\r\n\r\nurl <- \"https://docs.google.com/spreadsheets/d/15s7zeTEFT-fShou_jVYaHZHT3_9IvF6rgluUUdWy29Q/edit#gid=0\"\r\nsheet <- read.csv(text=gsheet2text(url, format='csv'), stringsAsFactors=FALSE, na.strings=c(\"\",\"NA\")) #emptry rows set to NAhttp://127.0.0.1:38813/graphics/plot_zoom_png?width=1920&height=1009\r\ncolnames(sheet) <- format_header(colnames(sheet))\r\n\r\n################################################################################################################\r\n################################################ Testing plots #################################################\r\n################################################################################################################\r\n\r\ncolumnName <- function(ColumnReference) { #from https://stackoverflow.com/a/14771584/11598009, function to retrieve colname as a string\r\n  return(substring(deparse(substitute(ColumnReference)),which(strsplit(deparse(substitute(ColumnReference)),\"\")[[1]]==\"$\")[1]+1))\r\n}\r\n\r\ncol.name.txt <- columnName(sheet$On.a.scale.from.1.5..how.interesting.do.you.find.the.publication..Kjemi..is.for.you..)\r\ncol.name.fill <- columnName(sheet$You.are..a..)\r\n\r\n#col.name.txt.sub <- gsub(pattern = \"\\\\.\\\\.\", replacement = \" \", x = col.name.txt)\r\n#col.name.txt.sub <- gsub(pattern = \"\\\\.\", replacement = \" \", x = col.name.txt.sub)\r\n\r\nsheet.NA.rm <- subset(sheet, !is.na(sheet[[col.name.txt]]))\r\nnrow(sheet.NA.rm)\r\n\r\n\r\nsheet.individual.means <- sheet.NA.rm %>% group_by(!!sym(col.name.fill)) %>% mutate(avg_score = mean(!!sym(col.name.txt))) %>% group_by(!!sym(col.name.fill))\r\nsheet.NA.rm[[col.name.fill]] <- reorder(sheet.NA.rm[[col.name.fill]], sheet.NA.rm[[col.name.txt]])\r\n\r\nscale.question = T\r\nggplot(sheet.individual.means, aes(x = if (scale.question==TRUE){as.character(sheet.individual.means[[col.name.txt]])}else {fct_rev(fct_infreq(as.character(sheet.individual.means[[col.name.txt]])))},\r\n)) + \r\n  geom_bar(aes(fill= sheet.individual.means[[col.name.fill]])) + \r\n  theme_classic() +\r\n  theme(legend.title = element_blank()\r\n        ) +\r\n  facet_wrap(vars(sheet.individual.means[[col.name.fill]])) +\r\n  geom_vline(aes(xintercept = sheet.individual.means$avg_score), size = 2, alpha = 0.3) +\r\n  geom_text(aes( x = 2.5, y = Inf, label = paste(\"Avg:\", format(round(sheet.individual.means$avg_score, 2), nsmall = 2))), check_overlap = TRUE, hjust=\"inward\", vjust =\"inward\")\r\n\r\n################################################################################################################\r\n################################################ Shiny #########################################################\r\n################################################################################################################\r\n\r\n\r\nui <- bootstrapPage(\r\n  \r\n  # App title ----\r\n  titlePanel(\"Choose input below\"),\r\n  \r\n  # Sidebar layout with input and output definitions ----\r\n  sidebarLayout(\r\n    \r\n    # Sidebar panel for inputs ----\r\n    sidebarPanel(\r\n      \r\n      # Input: Selector for variable to plot against count ----\r\n      # The below variables will be output as character strings\r\n      selectInput(\"variable\", \"Variable:\",\r\n                  choices = names(sheet) #all column names\r\n                    ),\r\n      selectInput(\"fill_value\", \"Fill:\",\r\n                  choices = c(\"None\", names(sheet)) #Adds a none for when filling is not necessary\r\n      ),\r\n      checkboxInput(\"facet.wrap\", \"Facet Wrap?\", value = FALSE),\r\n        numericInput('n_facet', 'Number of top facets', 6, min = 1, max = 7),\r\n        numericInput('font_size', 'Font size', 26),\r\n      numericInput('count_font_size', 'Count font size', 9),\r\n      downloadButton('downloadPlot')\r\n    ),\r\n    \r\n    # Main panel for displaying outputs ----\r\n    mainPanel(\r\n      \r\n      # Output: Formatted text for caption ----\r\n      h3(textOutput(\"caption\")),\r\n      \r\n      # Output: Plot of the requested variable against count ----\r\n      plotOutput(\"nks.plot\")\r\n      \r\n      \r\n    )\r\n  )\r\n)\r\n\r\nserver <- function(input, output) { #shiny passes selectInput as a string. To use these variables for subsetting dataframes, use e.g. df$!!sym(input$variable) or df[[input$variable]]\r\n  \r\n  formulaText <- reactive({\r\n  })\r\n  \r\n  # Return the formula text for printing as a caption ----\r\n  output$caption <- renderText({\r\n    formulaText()\r\n  })\r\n  \r\n  \r\n  # Generate a plot of the requested variable against count ----\r\n#  if(grepl(x = caption.txt, pattern = \"If you answered \")){\r\n    ##prepare Corpus from words\r\n    #text <- sheet[[input$variable]]\r\n    #print(text)\r\n    #docs <- Corpus(VectorSource(text))\r\n    #print(docs)\r\n    #docs <- tm_map(docs, removeWords, stopwords(\"Norwegian\")) #remove common words\r\n    #dtm <- TermDocumentMatrix(docs) #reformat\r\n    #matrix <- as.matrix(dtm) #reformat\r\n    #words <- sort(rowSums(matrix),decreasing=TRUE) \r\n    #df <- data.frame(word = names(words),freq=words)\r\n    #wordcloud_rep <- repeatable(wordcloud)   # Make the wordcloud drawing predictable during a session\r\n    #wordcloud(words = df$word,\r\n              #freq = df$freq,\r\n              #min.freq = 1,\r\n              #random.order=FALSE,\r\n              #rot.per=0.35,\r\n              #colors=brewer.pal(8, \"Dark2\"))\r\n#  }\r\n#  else{\r\n  bar_plot.reactive <- reactive({\r\n    \r\n    caption.txt <- format_header(input$variable)\r\n    \r\n    #scale-question parameters\r\n    scale.question <- grepl(x = input$variable, pattern = \"scale\", ignore.case = TRUE) #is this a question with a ranking from 1-5?\r\n    #unpack lists (cells with comma-separated, multiple values)\r\n    cells.w.multiple.value <- any(grepl(pattern = \",\", x = sheet[[input$variable]])) # check if any cells contain a comma\r\n    unique.answers <- nrow(subset(sheet, !is.na(sheet[[input$variable]])))\r\n    if (cells.w.multiple.value){\r\n      sheet.unpackt <- sheet %>% separate_longer_delim(!!sym(input$variable), delim = \", \")\r\n      sheet <- sheet.unpackt\r\n    }\r\n    \r\n    # remove NA\r\n    sheet.NA.rm <- subset(sheet, !is.na(sheet[[input$variable]]))\r\n    #handling counts for faceted plots\r\n    if(input$facet.wrap&scale.question){ #calculate the mean values pr group for scale questions\r\n      sheet.individual.means <- sheet.NA.rm %>% group_by(!!sym(input$fill_value)) %>% mutate(avg_score = mean(!!sym(input$variable)), na.rm = TRUE) %>% group_by(!!sym(input$variable)) \r\n      sheet.NA.rm <- sheet.individual.means\r\n      sheet.w.count <- sheet.NA.rm %>% group_by(!!sym(input$fill_value)) %>% add_count() #find the counts for each fill value\r\n      count_values <- sort(unique(sheet.w.count$n), decreasing=TRUE) #find unique count values, sorts them high->low\r\n      sheet.top.n.subset <- subset(sheet.w.count, subset = n %in% count_values[1:input$n_facet] ) # creates a subset of the dataset which contains only the top n counts (n is defined in the shiny app as n_facet)\r\n      sheet.NA.rm <- sheet.top.n.subset # pipelines the data\r\n    } else\r\n    if(input$facet.wrap){\r\n      validate(need(input$fill_value != \"None\", \"Please define a fill value\"))\r\n    sheet.w.count <- sheet.NA.rm %>% group_by(!!sym(input$fill_value)) %>% add_count() #find the counts for each fill value\r\n    count_values <- sort(unique(sheet.w.count$n), decreasing=TRUE) #find unique count values, sorts them high->low\r\n\r\n    sheet.top.n.subset <- subset(sheet.w.count, subset = n %in% count_values[1:input$n_facet] ) # creates a subset of the dataset which contains only the top n counts (n is defined in the shiny app as n_facet)\r\n    sheet.NA.rm <- sheet.top.n.subset # pipelines the data\r\n    }\r\n    \r\n    # let's plot\r\n\r\n    ggplot(\r\n      sheet.NA.rm, aes(x = if (scale.question==TRUE){as.character(.data[[input$variable]])} #numerical values from scale-questions are converted to text\r\n                       else {fct_rev(fct_infreq(as.character(.data[[input$variable]])))}\r\n                       ))+ #fct_infreq = order by count, fct_rev = reverse order. Scale questions should not be ordered by count, and needs to converted to character type\r\n    \r\n        {if(input$fill_value == \"None\") #if fill is \"None\", then fill with no color\r\n          geom_bar(fill=\"#005691\")\r\n          }+\r\n        {if(input$fill_value != \"None\")geom_bar( #if fill is defined as other than none, fill with fill parameters\r\n            aes(fill=\r\n                  if(scale.question){as.character(!!sym(input$fill_value))}  #convert scale-numbers (1 to 5) to characters\r\n                  else{!!sym(input$fill_value)}\r\n                  ) \r\n          )\r\n            }+ \r\n      geom_text(stat='count', size = input$count_font_size, aes(label=after_stat(count)), vjust=if(scale.question==FALSE){\"inward\"}else{\"inward\"}, hjust=if(scale.question==\"inward\"){-0.5}else{0}) +\r\n      theme_classic() +\r\n      {if(scale.question==FALSE)coord_flip()} + #scale question should not be coord-flipped.\r\n      {if(scale.question&input$facet.wrap==FALSE)geom_vline(xintercept = mean(sheet.NA.rm[[input$variable]]), size = 3, alpha = 0.4)} +\r\n      {if(scale.question&input$facet.wrap==FALSE)geom_text(aes( x = 2.5, y = Inf, label = paste(\"Avg:\", format(round(mean(sheet.NA.rm[[input$variable]]), 2), nsmall = 2))), check_overlap = TRUE, hjust=+1, vjust =\"inward\", size = (input$font_size/3))} +\r\n      labs(title = caption.txt,\r\n           subtitle = if(scale.question&input$facet.wrap){paste0(\"(n=\",unique.answers,\"/329, Avg:\",format(round(mean(sheet.NA.rm[[input$variable]]), 2), nsmall = 2), \")\")}\r\n           else{paste0(\"(n=\",unique.answers,\"/329)\")}\r\n             ) +\r\n      theme(text = element_text(size = input$font_size),\r\n            plot.title = element_textbox_simple(margin = margin(0,0,20,0)), #textbox enables line breaks, margin increased distance betwen plot/title\r\n            plot.title.position = if(str_length(caption.txt)>50){ \"plot\"}else{\"panel\"}, #if question gets too long, place it further left\r\n            legend.title = element_blank(),\r\n            axis.title.y = element_blank(),\r\n            axis.text.y = element_text(), #face=\"bold\" tested this, not sure if it's nicer\r\n            legend.position=if(input$facet.wrap){\"none\"}else{\"right\"}, \r\n            strip.placement = \"outside\",\r\n            ) +\r\n      {if(scale.question==TRUE)xlab(\"1 = Very little, 5 = Very much\")} + \r\n      ylab(\"Count\") +\r\n      # aggregate(sheet.NA.rm$`On a scale from 1 to 5 how interesting do you find the publication Kjemi is for you?`, list(sheet.NA.rm$`You are?`), mean) #calculate individual mean values\r\n      {if(input$facet.wrap)facet_wrap(.~fct_infreq(sheet.NA.rm[[input$fill_value]]), ncol = 2)} + #create individual plots\r\n      {if(input$facet.wrap&scale.question)geom_vline(aes(xintercept = sheet.NA.rm$avg_score), size = 2, alpha = 0.3)} +\r\n      {if(input$facet.wrap&scale.question)geom_text(aes( x = 1.5, y = Inf, label = paste(\"Group avg:\", format(round(sheet.NA.rm$avg_score, 2), nsmall = 2))), check_overlap = TRUE, hjust=\"inward\", vjust =\"inward\", size = (input$font_size/3)) }\r\n    \r\n  })\r\n  #}  This bracket is for the else\r\n  \r\n  output$nks.plot <- renderPlot(\r\n    { \r\n      bar_plot.reactive()\r\n    }\r\n  )\r\n  \r\n  output$downloadPlot <- downloadHandler(\r\n    filename <- function()\r\n    { if (input$facet.wrap){\r\n      paste0(\"NKS-plot-\",gsub(substrRight(input$variable, 60), pattern = \" \", replacement = \"_\"),\"-facet-wrap-\",input$fill_value, \".png\")\r\n    }else\r\n    {\r\n      paste0(\"NKS-plot-\",gsub(substrRight(input$variable, 60), pattern = \" \", replacement = \"_\"),\"fill-value-\", input$fill_value, \".png\")\r\n    }\r\n      },\r\n    content <- function(file){\r\n      png(file=file, width = 1500, height = 1000, pointsize = 24) #can we make this work with ggsave? https://stackoverflow.com/questions/14810409/how-to-save-plots-that-are-made-in-a-shiny-app probably not worth the hassle (right now)\r\n      plot(bar_plot.reactive())\r\n      dev.off()\r\n    }\r\n  )\r\n  \r\n  \r\n}\r\n\r\nshinyApp(ui, server)\r\n\r\n","type":"text"},{"name":"ReadMe.md","content":"# R-scripts for visualizing survey results\r\n","type":"text"}]
